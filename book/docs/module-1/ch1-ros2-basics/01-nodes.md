---
title: Nodes and the Graph
---

# Section 1: Nodes and the Graph

**Estimated Reading Time**: 7 minutes
**Bloom's Level**: Understand, Apply
**Key Learning**: What are ROS 2 nodes and how they form a computation graph

---

## What is a ROS 2 Node?

A **node** is an independent ROS 2 program. It's a single, focused process that does one thing well.

Think of it like this:
- Traditional robot code: One big program does everything (sensing, planning, control)
- ROS 2 code: Many small programs, each doing one thing (sensor driver, planner, controller)

### Real-World Analogy

Imagine a restaurant:
- **Traditional approach**: One chef does everything (prep, cooking, plating, cleaning)
- **ROS 2 approach**: Specialized stations
  - Prep station (sensor input)
  - Cooking station (processing)
  - Plating station (control)
  - Each station communicates with the next

### Why Nodes?

âœ… **Modularity**: Easy to understand, test, and reuse
âœ… **Reliability**: One failing node doesn't crash everything
âœ… **Scalability**: Run nodes on different computers
âœ… **Flexibility**: Mix and match nodes for different robots

---

## The ROS 2 Graph

A running ROS 2 system is a **graph** of communicating nodes:

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Sensor Driver Node     â”‚
         â”‚  (camera_node)          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                   [Topic: /image]
                        â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Processing Node        â”‚
         â”‚  (detector_node)        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                  [Topic: /detections]
                        â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Control Node           â”‚
         â”‚  (controller_node)      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Key components:
- **Nodes** (boxes): Independent programs
- **Topics** (arrows): Communication channels
- **Messages** (flow): Data traveling through topics

Each node:
- Runs independently
- Doesn't know about other nodes
- Only cares about topics it uses

---

## Your First ROS 2 Node: Hello, ROS 2!

Let's create the simplest possible ROS 2 node:

### Code Example 1: hello_node.py

**Location**: `code-examples/ros2_packages/hello_world_py/`

**Generated by**: `ros2-code-generator` skill

```python
# File: hello_world_py/hello_world_py/hello_node.py
import rclpy
from rclpy.node import Node

class HelloNode(Node):
    """Simple node that prints a greeting."""

    def __init__(self):
        # Initialize the node with name 'hello_node'
        super().__init__('hello_node')

        # Create a timer that calls a callback every 1 second
        self.timer = self.create_timer(1.0, self.timer_callback)

        # Counter for demonstration
        self.i = 0

    def timer_callback(self):
        """This function is called every 1 second."""
        self.get_logger().info(f'Hello, ROS 2! Message #{self.i}')
        self.i += 1

def main(args=None):
    # Initialize ROS 2
    rclpy.init(args=args)

    # Create and run the node
    node = HelloNode()
    rclpy.spin(node)  # Keep the node running (blocking call)

    # Cleanup
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Understanding the Code

**Line by line** (annotated by `code-explainer` subagent):

```python
import rclpy
```
- Import ROS 2 Python client library

```python
from rclpy.node import Node
```
- Import the Node base class (all ROS 2 nodes inherit from this)

```python
class HelloNode(Node):
```
- Create our custom node class that inherits from Node

```python
super().__init__('hello_node')
```
- Initialize the Node parent class
- `'hello_node'` is the node's unique name in the ROS 2 graph

```python
self.create_timer(1.0, self.timer_callback)
```
- Create a timer that calls `timer_callback` every 1.0 second
- Timers are how nodes do periodic work

```python
self.get_logger().info(...)
```
- Log a message visible in the console
- `get_logger()` is inherited from Node class

```python
rclpy.init(args=args)
```
- Initialize ROS 2 (must be called before creating nodes)

```python
rclpy.spin(node)
```
- Start the event loop for this node
- The node will keep running until you press Ctrl+C

---

## Running Your First Node

### Step 1: Build the Package

```bash
cd physical-ai-textbook/code-examples
colcon build --packages-select hello_world_py
```

### Step 2: Source the Environment

```bash
source ~/physical-ai-textbook/install/setup.bash
```

### Step 3: Run the Node

```bash
ros2 run hello_world_py hello_node
```

### Expected Output

```
[INFO] [hello_node]: Hello, ROS 2! Message #0
[INFO] [hello_node]: Hello, ROS 2! Message #1
[INFO] [hello_node]: Hello, ROS 2! Message #2
...
```

Press `Ctrl+C` to stop the node.

---

## Inspecting the Node

While the node is running (in another terminal), try these commands:

### See All Nodes

```bash
ros2 node list
```

Output:
```
/hello_node
```

### Get Node Information

```bash
ros2 node info /hello_node
```

Output:
```
/hello_node
  Subscribers:
  Publishers:
  Service Servers:
  Service Clients:
  Action Servers:
  Action Clients:
```

(This node doesn't publish or subscribe to anything yet - that's next!)

---

## Anatomy of a ROS 2 Node

Every ROS 2 node has these parts:

| Part | Purpose | Example |
|------|---------|---------|
| **Class** | Inherits from `Node` | `class HelloNode(Node)` |
| **`__init__`** | Create publishers, subscribers, timers | `self.create_timer()` |
| **Callback** | Code that runs when event happens | `timer_callback()` |
| **Main** | Entry point, init ROS, spin | `rclpy.init()`, `rclpy.spin()` |

---

## Node Lifecycle

Every ROS 2 node goes through these phases:

```
1. Initialize ROS 2
   rclpy.init()
         â†“
2. Create Node
   HelloNode()
         â†“
3. Create Resources (publishers, subscribers, services)
   self.create_timer(), self.create_publisher(), etc.
         â†“
4. Spin (keep running, process events)
   rclpy.spin(node)
         â†“
5. Shutdown
   rclpy.shutdown()
```

---

## Key Takeaways

âœ… A node is an independent ROS 2 program
âœ… Every node inherits from the `Node` class
âœ… Nodes are connected by topics and services
âœ… Nodes run independently and don't know about each other
âœ… Use timers to make nodes do work periodically

---

## Try It Yourself

Modify `hello_node.py` to:
- [ ] Change the message text
- [ ] Change the timer interval from 1.0 second to 2.0 seconds
- [ ] Remove the counter (don't increment `self.i`)
- [ ] Log messages at different levels: `.info()`, `.warning()`, `.error()`

---

## Next Steps

Now that you understand nodes, let's look at how they **communicate**:

ğŸ‘‰ **Next**: [Section 2: Topics - Publish and Subscribe](./02-topics.md)

Or jump to:
- [Section 3: Services](./03-services.md)
- [Exercises](./exercises.md)
- [Summary](./summary.md)

---

## Resources

- [ROS 2 Concepts - Nodes](https://docs.ros.org/en/humble/Concepts/Basic/About-Nodes.html)
- [Writing a Simple Publisher/Subscriber (Python)](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html)
- [rclpy.node.Node API](https://docs.ros2.org/humble/api/rclpy/api/node.html)

---

**Section Status**: Complete âœ…
**Skills Used**: `ros2-code-generator`, `code-explainer`
