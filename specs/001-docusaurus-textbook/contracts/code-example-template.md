# Code Example Template

Generated using `ros2-code-generator` skill. Annotated by `code-explainer` subagent.

---

## Example: [Name]

**Concept**: What does this code teach?
- Primary concept: [ROS 2 feature, pattern, or technique]
- Prerequisites: Understanding of [Chapter X concept]
- Duration**: 10-15 minutes to understand fully

---

## Motivation

Why does this example matter?

- Problem it solves: [Real-world use case]
- Connection to robotics: How does this apply?
- Difficulty progression: Beginner | Intermediate | Advanced

---

## Code Structure

**Package Location**: `code-examples/ros2_packages/[package-name]/`

**Files**:
- `package.xml` - ROS 2 package metadata
- `setup.py` - Python package installation
- `[package-name]/node.py` - Main implementation
- `launch/[launch-name].launch.py` - Launch file (if applicable)

---

## Full Code Example

```python
# File: [package-name]/[package-name]/node.py
# Generated by ros2-code-generator
# Annotated by code-explainer subagent

"""
Module docstring: What does this code do?

This module demonstrates [concept] in ROS 2.
It shows how to:
1. [Pattern 1]
2. [Pattern 2]
3. [Pattern 3]
"""

import rclpy
# Import Node base class for creating ROS 2 nodes
from rclpy.node import Node
# Import message types needed for this example
from std_msgs.msg import String

class ExampleNode(Node):
    """
    Example ROS 2 Node demonstrating [concept].

    This node:
    - Creates a publisher on topic '/example_topic'
    - Publishes a message once per second
    - Demonstrates proper ROS 2 node structure
    """

    def __init__(self):
        """Initialize the ROS 2 node with publisher and timer."""
        # Call parent class constructor with node name
        # The node name should be descriptive and follow ROS 2 naming conventions
        super().__init__('example_node')

        # Create a publisher that will publish String messages
        # Arguments: (message_type, topic_name, queue_size)
        # - message_type: std_msgs.String for simple text messages
        # - topic_name: '/example_topic' - subscribers will listen here
        # - queue_size: 10 - buffer up to 10 messages if no subscribers
        self.publisher_ = self.create_publisher(
            String,
            '/example_topic',
            10
        )

        # Create a timer that calls timer_callback() once per second
        # Arguments: (interval_in_seconds, callback_function)
        # This is how we periodically publish data in ROS 2
        self.timer = self.create_timer(1.0, self.timer_callback)

        # Counter to track how many messages we've published
        self.i = 0

    def timer_callback(self):
        """
        Callback function called by the timer at fixed intervals.
        This is where we publish our message.
        """
        # Create a new message object of type String
        msg = String()

        # Set the message content
        # In this case, we publish a simple text message
        msg.data = f'Hello, ROS 2! Message number {self.i}'

        # Publish the message to subscribers listening on '/example_topic'
        self.publisher_.publish(msg)

        # Log what we're doing (shown in 'ros2 node info' and logs)
        # Using logger helps with debugging and monitoring
        self.get_logger().info(f'Publishing: "{msg.data}"')

        # Increment counter for next message
        self.i += 1

def main(args=None):
    """
    Main function - entry point for the ROS 2 node.

    This function:
    1. Initializes the ROS 2 system
    2. Creates our node
    3. Runs the node (blocking call - listens for messages and runs callbacks)
    4. Cleans up on shutdown
    """
    # Initialize ROS 2 (required before creating any nodes)
    # args can be passed from command line if needed
    rclpy.init(args=args)

    # Create our node
    node = ExampleNode()

    # Spin the node - this is the main event loop
    # It will keep running, calling callbacks at appropriate times
    # Press Ctrl+C to stop the node
    rclpy.spin(node)

    # This code runs after Ctrl+C is pressed
    # Clean up the node and shut down ROS 2
    rclpy.shutdown()

# Python convention: only run main() if this file is executed directly
# (not when imported as a module elsewhere)
if __name__ == '__main__':
    main()
```

---

## Line-by-Line Explanation

**Imports (Lines 1-7)**:
- `rclpy`: ROS 2 client library for Python
- `Node`: Base class for all ROS 2 nodes
- `String`: Simple message type from std_msgs package

**Class Definition (Line 9)**:
- `ExampleNode(Node)`: Inherits from Node to get ROS 2 functionality
- Follows ROS 2 naming convention (suffix with "Node")

**__init__ Method (Lines 11-30)**:
- `super().__init__('example_node')`: Create node with name 'example_node'
- `create_publisher()`: Register a topic publisher (line 18)
- `create_timer()`: Create timer for periodic execution (line 27)

**timer_callback Method (Lines 32-44)**:
- Called once per second by the timer
- Creates and publishes a String message
- Increments counter for demonstration

**main() Function (Lines 46-61)**:
- Standard ROS 2 entry point
- `rclpy.init()` and `rclpy.spin()` are required for all ROS 2 nodes

---

## Key Concepts Demonstrated

**1. Node Creation**
```python
# Every ROS 2 node must inherit from Node and call super().__init__()
class MyNode(Node):
    def __init__(self):
        super().__init__('node_name')
```

**2. Publishing**
```python
# Create a publisher for a specific message type and topic
self.publisher_ = self.create_publisher(String, '/my_topic', 10)
# Publish a message
msg = String()
msg.data = 'data'
self.publisher_.publish(msg)
```

**3. Timer/Callbacks**
```python
# Create a timer that calls a function periodically
self.timer = self.create_timer(1.0, self.callback)
# The callback is called once per second
```

---

## Running the Example

**Build the Package**:
```bash
cd code-examples/ros2_packages/example_package
colcon build
```

**Run the Node**:
```bash
ros2 run example_package example_node
```

**Expected Output**:
```
[INFO] [example_node]: Publishing: "Hello, ROS 2! Message number 0"
[INFO] [example_node]: Publishing: "Hello, ROS 2! Message number 1"
[INFO] [example_node]: Publishing: "Hello, ROS 2! Message number 2"
...
```

**Listen to the Published Topic** (in another terminal):
```bash
ros2 topic echo /example_topic
data: 'Hello, ROS 2! Message number 5'
---
data: 'Hello, ROS 2! Message number 6'
---
```

---

## Common Variations

**Variation 1: Custom Message Type**
Instead of `String`, use custom message:
```python
from my_package.msg import CustomMessage
self.publisher_ = self.create_publisher(CustomMessage, '/topic', 10)
```

**Variation 2: Different Timer Interval**
```python
# Publish 10 times per second (0.1 second interval)
self.timer = self.create_timer(0.1, self.timer_callback)

# Publish once every 5 seconds
self.timer = self.create_timer(5.0, self.timer_callback)
```

**Variation 3: Dynamic Publishing**
Instead of timer-based, publish on-demand:
```python
# No timer - publish only when something happens
def some_event_handler(self):
    msg = String()
    msg.data = 'Event occurred!'
    self.publisher_.publish(msg)
```

---

## Troubleshooting

**Problem**: "ModuleNotFoundError: No module named 'std_msgs'"
- **Cause**: Dependencies not installed or package not sourced
- **Solution**: Run `colcon build` and source install: `source install/setup.bash`

**Problem**: "Node name 'example_node' already in use"
- **Cause**: Another instance of the node is running
- **Solution**: Kill other process or use unique node name

**Problem**: "The node published but no one received the message"
- **Cause**: Subscriber started after publisher finished publishing
- **Cause**: QoS settings don't match between publisher and subscriber
- **Solution**: Start subscriber before publisher or increase queue_size

---

## Extensions & Challenges

**Extension 1**: Add a subscriber to listen to messages
- See Chapter X for subscriber example
- Combine pub + sub in one node

**Extension 2**: Use parameters to control publishing rate
- Learn from Chapter Y, Exercise Z
- Allow runtime configuration without recompiling

**Extension 3**: Add error handling
- Handle initialization failures
- Add try/catch for robust code

---

## Metadata

**Skills Used**: ros2-code-generator, code-explainer
**Chapter**: [Chapter number and name]
**Section**: [Section number]
**Related Exercise**: [Exercise number if applicable]
**Package Location**: `code-examples/ros2_packages/[package-name]/`
**Estimated Time to Understand**: 10-15 minutes
**Difficulty**: Beginner | Intermediate | Advanced
**ROS 2 Version**: Humble 22.04
**Key Concepts**: [List of 3-5 key concepts demonstrated]
